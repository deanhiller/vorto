/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.vorto.routing;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Arrays;
import java.util.List;
import java.util.concurrent.ExecutionException;

import static jdk.dynalink.linker.support.CompositeTypeBasedGuardingDynamicLinker.optimize;

public class App {
    private static final Logger log = LoggerFactory.getLogger(App.class.getName());

    private ReadStuff readStuff = new ReadStuff();
    private CalculateBest calculateBest = new CalculateBest();

    public static void main(String[] args) {
        try {
            if (args.length != 1)
                throw new IllegalArgumentException("Takes exactly one arg, the filename");

            List<String> list = Arrays.asList(args);
            log.info("list=" + list);
            log.info("userdir=" + System.getProperty("user.dir"));

            //new App().start("../eng-challenge/trainingProblems/problem1.txt");
            new App().start(args[0]);
        } catch (Exception e) {
            log.error("exception", e);
            throw new RuntimeException(e);
        }
    }

    private void start(String arg) throws ExecutionException, InterruptedException {
        List<PickupDropoff> locations = readStuff.readInLocations(arg);
        //created MyMatrix so I could use toString to pretty print for debugging
        MyMatrix<Double> distances = calculateAll(locations);

        //for now, brute force different number of driver calculations HOWEVER
        //do this in multiple threads/servers so they come back with an answer at the same time
        Solution routes = calculateBest.routes(distances);

        int optimizationLevel = 3; // speed - optimization trade-off
        optimizeRoutes(routes, optimizationLevel);

        outputSolution(routes);
    }

    // a good python example in the 2nd half of the article is found here...
    //https://medium.com/@writingforara/solving-vehicle-routing-problems-with-python-heuristics-algorithm-2cc57fe7079c
    private void optimizeRoutes(Solution routes, int optimizationLevel) {
        //modify the routes here in place...
    }

    private void outputSolution(Solution solution) {
        Double totalCost = 500.0 * solution.getRoutes().size();

        //validating out cost of location 0 to location 2 back to location 0 which was 288.46
        //to pickup sqrt((0-73)^2+(0--86)^2)+
        //to dropoff sqrt((-116-73)^2+(76--86)^2)+  GRRR, wrong -> sqrt((-57-73)^2+(28--86)^2)
        // to home sqrt((-57-0)^2+(28-0)^2) GRRR, wrong ->
        //sqrt((0-73)^2+(0--86)^2)+sqrt((-116-73)^2+(76--86)^2)+sqrt((0--116)^2+(0-76)^2) - GRRR, this was wrong
        //fixed -> sqrt((0-73)^2+(0--86)^2)+sqrt((-57-73)^2+(28--86)^2)+sqrt((-57-0)^2+(28-0)^2)
        //cost is 500.4 (I rounded so just need to be close here)...I am off, go fix that
        //
        //looking at our matrix, we have 113(to pickup) + 174(the route) + 64(go home) = 351 (not 500)
        //
        //and our program output a cost of 288.
        //
        //LMAO. so 3 values mismatched however to pickup + route = 287 so we forgot the go home path there.
        //This is fixed. we get 352(rounding errors as I cheat a bit)
        //
        //next re-validate matrix vs. my 113, 174, 64.  1st one right, both of the others are off.
        //my formula now is 113, 173, 63.5 so we match the values
        //
        //total cost 349.   logs show 352.8 (rounding errors of course)

        for(int i = 0; i < solution.getRoutes().size(); i++) {
            List<Integer> route = solution.getRoutes().get(i);
            Double cost = solution.getRouteCosts().get(i);
            totalCost += cost;
            String myLine = printList(route);
            log.info("myLine="+myLine+" routeCost="+cost);
            System.out.println(myLine);
        }

        log.info("TOTAL cost="+totalCost);
    }

    public String printList(List<Integer> list) {
        // Use StringBuilder for efficient string concatenation
        StringBuilder sb = new StringBuilder();
        sb.append("[");

        for (int i = 0; i < list.size(); i++) {
            sb.append(list.get(i));
            if (i < list.size() - 1) {
                sb.append(", ");
            }
        }

        sb.append("]");
        return sb.toString();
    }

    private MyMatrix<Double> calculateAll(List<PickupDropoff> locations) {
        //Example best here.
        //Matrix location 1, 2 will be
        //      distance between loadNumber 1's dropoff location and loadNumber 2's pickup location
        //Matricx location 2, 1 will be
        //      distance between loadNumber 2's dropoff location and loadNumber 1's pickup location
        //Matrix location 1, 1 will be
        //      distance of the actual route pickup to dropoff for location 1

        MyMatrix<Double> myMatrix = new MyMatrix<>(new Double[locations.size()][locations.size()]);

        //NOTES: after having a first version wor

        for(int n = 0; n < locations.size(); n++) {
            //since we are a square, we can access all locations a bit fast by not reading the entire
            //row each time...
            for(int m = 0; m <= n; m++) {
                PickupDropoff loc1 = locations.get(n);
                PickupDropoff loc2 = locations.get(m);
                Double distance1 = calculateDropoffToNextPickup(loc1, loc2);
                myMatrix.set(n, m, distance1);

                if(n == m)
                    continue; // no sense in repeating ourself here since loc1 and loc2 are the same location

                Double distance2 = calculateDropoffToNextPickup(loc2, loc1);
                myMatrix.set(m, n, distance2);
            }
        }

        log.info("myMatrix=\n"+myMatrix);
        return myMatrix;
    }

    private Double calculateDropoffToNextPickup(PickupDropoff previous, PickupDropoff next) {
        GeoLocation dropoff = previous.getDropoff();
        GeoLocation pickup = next.getPickup();
        return calcDistance(dropoff, pickup);
    }

    private double calcDistance(GeoLocation dropoff, GeoLocation pickup) {
        //sqrt((x2-x1)^2 + (y2-y1)^2)
        double x = pickup.getLatitude() - dropoff.getLatitude();
        double y = pickup.getLongitude() - dropoff.getLongitude();
        return Math.sqrt(x*x + y*y);
    }


}
